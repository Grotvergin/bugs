# -*- coding: utf-8 -*-
"""resultparser.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vm0Rkss-nOKLL04Ld41pL79-zdE7ki8y
"""
import sys
import csv
import os

def get_distance(points):
  sum = 0
  for i in range(len(points)):
    if i != 0:
      sum += points[i].distance(points[i-1])
  return sum

def matches(points):
  #result repeated distance
  res = 0.0
  matched = []
  #pairs of similar points
  pairs = []
  firsts = []
  seconds = []
  last_after = 0
  prev_pair = None
  last_pair_found = None
  last_seq = 0
  is_seq = False
  #sequence length
  seq_counter = 0
  seqs = []
  #check all pairs of points
  for i, point in enumerate(points):
      for j, point in enumerate(points):

          first = i
          second = j
          a = True
          lst_first = first
          count = 0
          #if points are similar
          if i!=j and math.sqrt((points[i].Y - points[j].Y)**2 + (points[i].X - points[j].X)**2) < 0.1:

            #while next points are similar
            while a:

              if first > len(points) - 3 or second > len(points) - 2:

                  a = False

              if first!=second and math.sqrt((points[first].Y - points[second].Y)**2 + (points[first].X - points[second].X)**2)< 0.1:

                pair = [first, second] # found pair
                #if not counted
                if [first, second] not in matched and [second, first] not in matched:
                  last_pair_found = pair

                  if prev_pair is not None: #check previous pair
                    if pair[0] - prev_pair[0] == 1 and pair[1] - prev_pair[1] == 1: #if prev pair were points right before current pair
                      is_seq = True
                      seq_counter += 1 #increment current sequence length
                      last_seq = seq_counter
                    else:

                      seqs.append(seq_counter + 1) #finish sequence, add to sequences
                      #print("seq_counter ", seq_counter)
                      last_seq = 0
                      is_seq == False
                      seq_counter = 0
                  prev_pair = pair

                  count += 1
                  last_after = count
                  firsts.append(first)
                  seconds.append(second)
                  pairs.append(pair) #add found pair

                  #we do not need to count a,b and b,a twice. It is the same pair

                  matched.append([first, second])
                  matched.append([second, first])

                first += 1
                second += 1


              else:

                a = False


  seqs.append(seq_counter + 1)
  sequences = []

  #we find arrays of sequence length to define sequences of points
  for i, s in enumerate(seqs):
    s1 = pairs[0+s:0+s+s]
    f = [a[0] for a in s1]
    s = [a[1] for a in s1]
    if f not in sequences:
      sequences.append(f)
    if s not in sequences:
      sequences.append(s)

  counted = []


#take all sequences of points and add distance if it is not counted
  for s in sequences:
      for i in range(len(s)):
        if i != 0:
          if [s[i-1], s[i]] in counted or [s[i], s[i-1]] in counted:
            pass
          else:

            counted.append([s[i], s[i-1]])
            counted.append([s[i-1], s[i]])
            res += points[s[i]].distance(points[s[i - 1] ])



  return res

import math


class Point(object):

    def __init__(self, x, y):
        self.X = x
        self.Y = y


    def getX(self):
        return self.X

    def getY(self):
        return self.Y

    def __repr__(self):
      res = ''
      res += "X: "
      res += str(self.X)
      res += " Y: "
      res += str(self.Y)
      return res

    def distance(self, other):
        dist = math.sqrt((self.Y - other.Y)**2 + (self.X - other.X)**2)
        return dist

def get_all_criteria(filename, x, y, fname, alg):
  file_contents = ""
  with open(filename, "r") as f:
      for line in f:
          file_contents += line
  output_stream = os.popen('gz stats -p --duration=1')
  stats = output_stream.read()
  first = True
  val = stats.split(',')
  rtf = val[3].split('\n')[1]
  results = file_contents.split('\n')
  result_time = results[0].split(': ')[1]
  obstacles_count = results[1].split(': ')[1]
  all_points = results[2].split(': ')[1][1:-1].split('; ')
  memory_usage = results[3].split(': ')[1]
  complexity = results[4].split(': ')[1]
  calculation_time = results[5].split(': ')[1]
  turn_degrees = results[6].split(': ')[1]
  points = []
  for p in all_points:
    coordinates = p.split(' ')
    point = Point(float(coordinates[0]), float(coordinates[1]))
    points.append(point)
  repeats = matches(points)
  criteria = dict()
  criteria['Algorithm'] = alg
  criteria['X'] = x
  criteria['Y'] = y
  criteria['Map Name'] = fname
  criteria['Total Time'] = result_time
  criteria['Obstacles Hit'] = obstacles_count
  criteria['Path Length'] = get_distance(points)
  criteria['Memory Usage'] = memory_usage
  criteria['Complexity'] = complexity
  criteria['Calculation Time'] = calculation_time
  criteria['Total Rotation(in degrees)'] = turn_degrees
  criteria['Sum of Repeated Segments'] = repeats
  criteria['Real Time Factor'] = rtf

  header = ['Algorithm','X','Y', 'Map Name','Path Length','Total Time','Complexity','Obstacles Hit','Sum of Repeated Segments','Total Rotation(in degrees)','Memory Usage','Calculation Time','Real Time Factor']

  if os.path.isfile('critFile.csv'):
    critFile = open('critFile.csv', 'a')
    writer = csv.DictWriter(critFile, fieldnames = header)
  else:
    critFile = open('critFile.csv', 'w+')
    writer = csv.DictWriter(critFile, fieldnames = header)
    writer.writeheader()
  writer.writerow(criteria)
  critFile.close()
  return

if __name__ == "__main__":
    get_all_criteria(sys.argv[1], sys.argv[2], sys.argv[3], sys.argv[4], sys.argv[5])
    sys.exit()
